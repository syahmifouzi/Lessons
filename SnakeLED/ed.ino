/* Main.ino file generated by New Project wizard
 *
 * Created:   Thu Sep 5 2013
 * Processor: ATmega2560
 * Compiler:  Arduino AVR
 */
 
 /*
  3x3x4 LED Cube
  Connection Setup: 
  Columns
  [(x,y)-Pin]
  (1,1)-0
  (1,2)-1
  (1,3)-2
  (1,4)-3
  (2,1)-4
  (2,2)-5
  (2,3)-6
  (2,4)-7
  (3,1)-8
  (3-2)--
  (3-3)--
  (3,4)--
  (4,1)--
  (4,2)--
  (4,3)--
  (4,4)--
  Layers
  [layer-Pin]
  a-9
  b-10
  c-11
  d-12
*/

//initializing and declaring led rows and columns
// int row[6]={0,1,2,3,4,5};
// int column[6]={9, 10, 11, 12};

// #include <iostream>

using namespace std;

struct Point             // use proper formatting
{   
    int X;
    int Y;
} ;

typedef  Point* PointsArr;
static const int size=10;

// the follow variables are long's because the time, measured in miliseconds,
// will quickly become a bigger number than can be stored in an int.
long time = 0;         // the last time the output pin was toggled
long debounce = 200;   // the debounce time, increase if the output flickers
int reading;           // the current reading from the input pin
int previous = LOW;    // the previous reading from the input pin
long time2 = 0;         // the last time the output pin was toggled
int reading2;           // the current reading from the input pin
int previous2 = LOW;    // the previous reading from the input pin

class Snake {
   public:
      Snake();   // This is the constructor declaration
      ~Snake();  // This is the destructor: declaration
      void moveS(void);
      void turnLed(void);
      void checkBtn(void);
      void checkBle(void);
      void setFood(int f);
      void setBle(bool f);
      void reset(void);
      bool getLose(void);
 
   public:
      int length;
      int lengthCount;
      char facing;
      int food;
      bool lose;
      bool bleFlag;
      // PointsArr test=new Point[size];
      PointsArr body = new Point[size];
      int bodyCount[size];
};

// Member functions definitions including constructor
Snake::Snake(void) {
   // cout << "Object is being created" << endl;
   //printf("Object is being created");
   //Serial.begin(9600);

   for(int i = 0; i<38; i++)
  {
    pinMode(i, OUTPUT);
  }
   pinMode(38, INPUT_PULLUP);
   pinMode(39, INPUT_PULLUP);

  // memset(test,0,size*sizeof(Point));
  memset(body,0,size*sizeof(Point));

  for(int i=0;i<10;i++)
  {
    body[i].X=0;
    body[i].Y=0;
  }

  for (int j=0; j<sizeof(bodyCount)/sizeof(bodyCount[0]); j++) {
      bodyCount[j] = 0;
   }

  length = 3;
  lengthCount = 3;

  int setx = length;
  int sety = 2;
  for(int i=0;i<length;i++)
  {
    body[i].X = setx;
    body[i].Y = sety;

    setx--;
  }
   
  //  body[0].X = 3;
  //  body[0].Y = 2;
   
  //  body[1].X = 2;
  //  body[1].Y = 2;
   
  //  body[2].X = 1;
  //  body[2].Y = 2;
   
  //  length = 3;
   facing = 'D';
   lose = false;
}

Snake::~Snake(void) {
   //cout << "Object is being deleted" << endl;
   //printf("Object is being deleted");
}

void Snake::moveS(void) {

for (int i = length-1; i > 0; i--) {
   
   body[i].X = body[i-1].X;
   body[i].Y = body[i-1].Y;
      }

switch (facing) {
      
  case 'W':
    // statements
    body[0].Y -= 1;
    
    if (body[0].Y < 0) {
      body[0].Y = 5;
      }
    break;
  case 'D':
    // statements
    body[0].X += 1;
    
    if (body[0].X == 6) {
      body[0].X = 0;
      }
    break;
   case 'X':
   body[0].Y += 1;
    
    if (body[0].Y == 6) {
      body[0].Y = 0;
      }
      break;
   case 'A':
   body[0].X -= 1;
    
    if (body[0].X < 0) {
      body[0].X = 5;
      }
      break;
  default:
    // statements
    break;
}

  int r = body[0].Y;
  int c = body[0].X;
  int n = 6 * r + c;

  for(int j = length; j < lengthCount; j++)
  {
    bodyCount[j] = bodyCount[j] - 1;

    if(bodyCount[j] == 0)
    {
      length++;
    }
  }

  for(int k = 1; k < length; k++)
  {
    int r1 = body[k].Y;
    int c1 = body[k].X;
    int n1 = 6 * r1 + c1;

    if(n == n1)
    {
      lose = true;
    }
  }


  if(n == food)
  {
    body[lengthCount].X = body[0].X;
    body[lengthCount].Y = body[0].Y;

    bodyCount[lengthCount] = lengthCount;

    lengthCount++;

    int foodr = 0;
    bool pass = true;

    while(true)
    {
      foodr = random(36);
      for(int l = 0; l < length; l++)
      {
        int r2 = body[l].Y;
        int c2 = body[l].X;
        int n2 = 6 * r2 + c2;

        if(foodr == n2)
        {
          pass = false;
        }
      }
      if(pass) break;
    }
    setFood(foodr);
  }
}

 ////////////////////////////////turn on an led
 void Snake::turnLed(void)
 {
  //Serial.begin(9600);
   // first we turn it all off
   for (int i = 0; i < 38; i++) {
      digitalWrite(i, 0);
   }

   //digitalWrite(food, 1);
   //digitalWrite(22, 1);
   
   // then, turn some on
   for (int i = 0; i < length; i++) {
      int r = body[i].Y;
      int c = body[i].X;
      int n = 6 * r + c;

      if(n == 0)
      {
        n = 37;
      } else if (n == 1)
      {
        n = 36;
      }

      //Serial.println(r);
      //Serial.println(c);
      //Serial.println(n);

      //Serial.println(n);
      digitalWrite(n, 1);
   }
   digitalWrite(food, 1);
   
 }

 void Snake::setFood(int f)
 {
   food = f;
 }

 void Snake::setBle(bool f)
 {
   bleFlag = f;
 }
 
 void Snake::checkBtn(void)
 {
  
  reading = digitalRead(38);
  reading2 = digitalRead(39);
  
  // using else if below to prevent both switch command at the same time

  // if the input just went from LOW and HIGH and we've waited long enough
  // to ignore any noise on the circuit, toggle the output pin and remember
  // the time
  if (reading == LOW && previous == HIGH && millis() - time > debounce) {
    
    switch (facing) {
      
      case 'W':
        // statements
        facing = 'A';
        break;
      case 'D':
        // statements
        facing = 'W';
        break;
      case 'X':
      facing = 'D';
          break;
      case 'A':
      facing = 'X';
          break;
      default:
        // statements
        break;
    }

    time = millis();    
  } else if (reading2 == LOW && previous2 == HIGH && millis() - time2 > debounce) {
     switch (facing) {
      
        case 'W':
          // statements
          facing = 'D';
          break;
        case 'D':
          // statements
          facing = 'X';
          break;
        case 'X':
        facing = 'A';
            break;
        case 'A':
        facing = 'W';
            break;
        default:
          // statements
          break;
      }

    time2 = millis();    
  }

  previous = reading;
  previous2 = reading2;
   
 }

void Snake::checkBle(void)
{
  char blueToothVal = 'n';
  if(Serial.available() )
  {//if there is data being recieved
    blueToothVal=Serial.read(); //read it

    if(bleFlag)
    {

    if (blueToothVal=='1')
    {//if value from bluetooth serial is 1 --> turn left
      
      switch (facing) {
      
      case 'W':
        // statements
        facing = 'A';
        break;
      case 'D':
        // statements
        facing = 'W';
        break;
      case 'X':
      facing = 'D';
          break;
      case 'A':
      facing = 'X';
          break;
      default:
        // statements
        break;
    }

    }
    else if (blueToothVal=='0')
    {//if value from bluetooth serial is 0 --> turn right
      
      switch (facing) {
      
        case 'W':
          // statements
          facing = 'D';
          break;
        case 'D':
          // statements
          facing = 'X';
          break;
        case 'X':
        facing = 'A';
            break;
        case 'A':
        facing = 'W';
            break;
        default:
          // statements
          break;
      }

    }
    bleFlag = false;
    }
  }
  
  // delay(1000);
}

void Snake::reset(void)
{

for(int i=0;i<10;i++)
  {
    body[i].X=0;
    body[i].Y=0;
  }

  for (int j=0; j<10; j++) {
      bodyCount[j] = 0;
   }

  length = 3;
  lengthCount = 3;

  int setx = length;
  int sety = 2;
  for(int i=0;i<length;i++)
  {
    body[i].X = setx;
    body[i].Y = sety;

    setx--;
  }

   facing = 'D';
   lose = false;
   int foodr = random(36);
   //  int b = random(5,20);
   setFood(foodr);

}

bool Snake::getLose(void)
{
  return lose;
}

Snake snake = Snake();

// https://oscarliang.com/arduino-timer-and-interrupt-tutorial/
int timer1_counter;
volatile bool isrCount;

void setup()
 { // put your setup code here, to run once:
 //setting rows to ouput

  Serial.begin(9600);
  // seeding random for random pattern
  randomSeed(analogRead(0));

  // initialize timer1 
  noInterrupts();           // disable all interrupts
  TCCR1A = 0;
  TCCR1B = 0;
  // Set timer1_counter to the correct value for our interrupt interval
  timer1_counter = 45000;   // preload timer 65536-16MHz/256/(XXXHz)
  
  TCNT1 = timer1_counter;   // preload timer
  TCCR1B |= (1 << CS12);    // 256 prescaler 
  TIMSK1 |= (1 << TOIE1);   // enable timer overflow interrupt
  interrupts();             // enable all interrupts

  isrCount = false;
 }

 ISR(TIMER1_OVF_vect)        // interrupt service routine 
{
  TCNT1 = timer1_counter;   // preload timer
  isrCount = true;
}

void loop()
 { // put your main code here, to run repeatedly:
 
//  int level = 250;
snake.reset();

while(!snake.getLose())
{
  isrCount = false;
  snake.turnLed();
  snake.moveS();
  snake.setBle(true);
  snake.checkBle();
  while(!isrCount)
  {
    snake.checkBle();
  }
}
 
//  for (int i = 0; i < 1000; i++) {

//     isrCount = false;
//     //for(float f=0;f<83000;f++){
//     //  if (isrCount != 0) break;
//     //}
//     // while(!isrCount)
//     // {
//     //   snake.checkBle();      
//     // }
//     // isrCount = false;
//     snake.turnLed();
   
//     snake.moveS();
//     snake.checkBle();
//     //delay(level);
//     while(!isrCount)
//     {
//       snake.checkBle();
//     }
//     //for(float f=0;f<83000;f++){
//     //  if (isrCount != 0) break;
//     //}
//  }
 
 }
